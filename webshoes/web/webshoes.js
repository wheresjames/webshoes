
/**
    @param opts     - Options
                        [in]
                            url         : The websocket connection url
                            uid         : Random id, autogenerated if not proided
                            cb          : Callback for warnings and errors
                            reconnect   : Reconnect delay in milliseconds
                        [out]
                            isOpen      : Set to true if connection is open, else false
                            msg         : Call to send message
                            onEvent     : Call to hook server side events
                        [internal]
                            xx          : Websocket
                            cbmap       : Callback map
                            evmap       : Events callback map
*/
function WebShoes(opts)
{
    if (!opts.uid)
        opts.uid = `${new Date().getTime()}-${Math.random()}`;

    if (!opts.cbmap)
        opts.cbmap = {};

    if (!opts.evmap)
        opts.evmap = {};

    if (!opts.reconnect)
        opts.reconnect = 3000;

    try
    {
        let xx = new WebSocket(opts.url);

        // Callback when ws connection is opened
        xx.onopen = ()=>
        {
            opts.isOpen = true;

            // Rehook events
            for (let k in opts.evmap)
                for (let v of opts.evmap[k])
                {   if (opts.cb)
                        opts.cb('rehook', v)
                    opts.xx.send(JSON.stringify(v.msg));
                }

            if (opts.cb)
                opts.cb('open');
        };

        // Callback when ws connection is closed
        xx.onclose = ()=>
        {
            opts.isOpen = false;
            if (opts.cb)
                opts.cb('close');
            setTimeout(() => { WebShoes(opts); }, opts.reconnect);
        };

        // Callback when ws error
        xx.onerror = (e)=>
        {
            if (opts.cb)
                opts.cb('error', e.message ? e.message : e);
        };

        // Callback when message recieved from ws
        xx.onmessage = (msg)=>
        {
            try
            {
                let j = JSON.parse(msg.data);
                if (j.error && opts.cb)
                    opts.cb('error', j.error);
                if (j.warning && opts.cb)
                    opts.cb('warning', j.warning);

                // See if there is a callback for this transaction id
                if (j.tid && j.tid in opts.cbmap)
                {
                    let tid = j.tid;
                    let v = opts.cbmap[tid];

                    // If callback and it's still valid
                    if (j.r && v.cb)
                        if (!v.id || opts._q(v.id))
                            v.cb(j.r, v.msg);

                    delete opts.cbmap[tid];
                }

                // If it is an event, see if there is a matching event callback
                else if (j.evt && j.evt in opts.evmap)
                {
                    // Filter invalid callbacks
                    opts.evmap[j.evt] = opts.evmap[j.evt].filter(v=>v.cb && (!v.id || opts._q(v.id)));

                    // For each callback entry
                    for (let k in opts.evmap[j.evt])
                    {
                        let v = opts.evmap[j.evt][k];

                        if (!j.r)
                            j.r = {};

                        // Call callback
                        v.cb(j.r, v.msg);
                    }
                }

            }
            catch(e)
            {   console.log(e);
                if (opts.cb)
                    opts.cb('error', e.message ? e.message : e);
            }
        };

        /**
            @param [in] id      - This should be a valid html element.  If the
                                  html element is not valid or does not exist,
                                  the callback will not be made.
        */
        xx.msg = (id, cmd, params, cb) =>
        {
            if (!opts.isOpen && cb)
                return cb({'error': 'Not connected'});

            // Create message
            let t = new Date().getTime()/1000;
            let tid = `${t}-${Math.random()}`;
            let msg = { uid: opts.uid, cmd: cmd, q: params, tid: tid, t: t };

            // Add callback
            opts.cbmap[tid] = {id: id, cb: cb, msg: msg};

            // Send the message
            opts.xx.send(JSON.stringify(msg));
        };

        xx.onEvent = (id, evt, params, cb) =>
        {
            // Create message
            let t = new Date().getTime()/1000;
            let tid = `${t}-${Math.random()}`;
            let msg = { uid: opts.uid, evt: evt, q: params, tid: tid, t: t };

            // Add entry if needed
            if (!(evt in opts.evmap))
                opts.evmap[evt] = [];

            // Remove duplicates
            opts.evmap[evt] = opts.evmap[evt].filter(n=>n.id != id || n.msg.evt != evt);

            // Add callback
            opts.evmap[evt].push({id: id, cb: cb, msg: msg});

            // Send the message
            if (opts.isOpen)
                opts.xx.send(JSON.stringify(msg));
            else
                return cb({'error': 'Not connected'});
        };

        opts.xx = xx;
        opts.msg = xx.msg;
        opts.onEvent = xx.onEvent;

        // Call to get DOM item using selector
        opts._q = document.querySelector.bind(document);

        // Adds a unique div to the specified DOM element and retuns the id selector
        opts.addPageId = (id) =>
        {   let div = opts._q(id);
            if (!div) return null;
            let pid = `WebShoesPageId-${new Date().getTime()}-${String(Math.random()).replace(/\D/g,'')}`;
            let tmp = document.createElement('div');
            tmp.innerHTML = `<div id="${pid}" style="display:none"></div>`;
            div.appendChild(tmp.firstChild);
            return `#${pid}`;
        };

    }
    catch(e)
    {
        if (opts.cb)
            opts.cb('error', e.message ? e.message : String(e)),
            opts.cb('close');
        setTimeout(() => { WebShoes(opts); }, opts.reconnect);
    }
    return opts;
}

